---
title: 가볍게 마이크로서비스 구축해보기-1
categories:
  - Microservice
feature_text: |
  ## 마이크로서비스 아키텍처(Microservices Architecture) 소개
---

#### Goal

> 마이크로서비스 아키텍처(이하 MSA)에 대한 소개는 이제 다소 진부 하다고 느낄 수 있을 정도로 이미 많은 곳에서 소개가 되어왔고, 관련 정보들은 어렵지 않게 찾아볼 수 있습니다. 하지만, 이론적인 내용과 더불어 가볍게나마 MSA 기반의 시스템을 간단히 구현해 볼 수 있는 예제 코드를 제공하는 포스트라면 나름 의미가 있겠다 싶어 부족하게나마 이 연재를 준비해보게 되었습니다.

MSA를 본격적으로 설명하기에 앞서 이 아키텍처가 기존에 어떠한 문제를 해결하고자 했는지를 설명하기 위해 먼저 모놀리식 아키텍처(Monolithic Architecture)를 살펴보겠습니다.

#### 모놀리식 아키텍처

<p align="center">
  <img src="/assets/1_5LZewlbhokfBRgt0J31NyQ.png">
</p>

위 그림과 같이 모놀리식 아키텍처는 시스템을 구성하는 컴포넌트들이 하나의 유닛으로 구현됩니다. 이러한 아키텍처에 기반하여 SNS 서비스를 개발 한다고 가정하면, 해당 서비스를 구성하는 여러 컴포넌트들(포스트, 메신저, 광고 등)을 하나의 WAR 파일로 패키징 하고 WAS에 배포하여 운영하는 스타일이라고 보시면 됩니다.

이러한 방식은 처음 작은 규모의 애플리케이션을 개발하고 운영할 때는 적합할 수 있으나, 규모가 커질수록 다음과 같은 문제들을 수반하게 됩니다.

- 비효율적인 배포

  : 특정 하나의 컴포넌트를 수정하더라도 전체 애플리케이션을 다시 재 컴파일하여 배포해야 합니다.
- 컴포넌트 간의 장애 전파

  : 특정 하나의 컴포넌트에서의 장애가 다른 컴포넌트들에게 전파될 가능성이 높습니다. 따라서, 개발자는 전체 시스템을 이해해야 하는 수고가 필요할 수 있습니다.
- 비효율적인 하드웨어 자원 활용
  
  : 각 컴포넌트 별로 요구되는 하드웨어 리소스가 다름에도 불구하고 하나의 애플리케이션으로 패키징되어 있어 하드웨어 리소스를 컴팩트하게 할당하기 어렵습니다.
- 새로운 기술스택 도입의 어려움

  : 부분적으로 새로운 기술스택들(언어, 라이브러리, 프레임워크, DBMS 등)을 적용하기가 어렵습니다.

이러한 모놀리식 아키텍처의 단점은 대부분 컴포넌트들 간의 강한 결합도(Coupling)에서 기인합니다. 그래서 MSA와 같이 컴포넌트들간의 결합도를 낮춘 아키텍처는 앞서 언급된 문제들을 효과적으로 해결하기 위한 좋은 대안이 될 수 있습니다.

#### 마이크로서비스 아키텍처

**Martin Fowler는 MSA를 다음과 같이 정의 했습니다.**

“마이크로서비스 아키텍처는 독립적으로 배포 가능한 작은 서비스들의 조합으로 단일 애플리케이션을 설계하기 위한 방법이다.”

<p align="center">
  <img src="/assets/1_GG3DuzwxchbYbtGk0CXhPQ.png">
</p>

위 그림과 같이 MSA는 시스템을 구성하는 컴포넌트들이 작은 서비스의 단위로 분리되어 독립적으로 배포됩니다. 서비스의 경우 보통 도메인을 기준으로 나눕니다.

이렇게 컴포넌트들간의 결합도를 낮춘 것만으로도 앞서 언급했던 모놀리식 아키텍처의 단점들은 효과적으로 해결될 수 있습니다. 또한, 조직이 점차 작은 조직들로 세분화 되고 각 조직이 담당한 서비스에 대해 오너쉽을 가지고 애자일하게 일하는 문화가 트랜드인 요즘 MSA는 좋은 선택지가 될 수 있습니다.

하지만, 세상엔 공짜가 없듯이… MSA도 다음과 같은 단점들을 수반합니다.

- 성능 이슈

  : 서로 독립적인 서비스로 분리된 컴포넌트들은 이제 API 통신을 통해 데이터를 주고받아야 하기 때문에 성능 저하가 발생할 수 있습니다.

- 트랜잭션 관리의 어려움

  : 서로 독립적인 서비스로 분리된 컴포넌트들 간의 발생한 트랜잭션을 관리하기가 어려워 집니다.

- 데이터 무결성 보장의 어려움

  : 서비스 단위로 분리된 데이터 레이어 간의 역정규화(Denormalization)를 하게 될 경우, 해당 데이터에 대한 무결성을 보장하기 어렵습니다.

위에서 ‘트랜잭션 관리의 어려움’과 ‘데이터 무결성 보장의 어려움’은 MSA를 이상적으로 디자인 하면 발생하지 않는 문제라고 하는 글들을 간혹 보았는데, 현실에서는 최소한으로 줄일 수는 있어도 필연적으로 마주할 수 밖에 없다고 생각합니다.

이렇게 물리적으로는 분리되어있는 컴포넌트들이지만 논리적으로는 하나의 애플리케이션 처럼 동작해야 하기 때문에, MSA는 모놀리식 아키텍처에 비해 시스템의 복잡도가 올라가고 상당히 높은 기술력을 요구합니다. 그래도 다행인 것은 MSA와 관련하여 유용한 오픈소스들이 공개되어 있어 우리들의 부담을 덜어 주고 있습니다.

이 연재의 목적은 빠르고 가볍게 MSA 기반의 시스템을 구현해보는 것이기 때문에 필수적이라고 생각되는 구성들만을 아래와 같이 뽑아 보았습니다.

- Service Discovery

  : 각 서비스들의 네트워크 위치 정보(IP, Port)를 저장하고 관리합니다. 특히 클라우드와 같이 각 서비스의 네트워크 정보가 동적으로 바뀔 수 있는 환경에서는 필수적입니다.
- API Gateway

  : 서비스에 해당하는 각 API 서버의 엔드 포인트를 단일화 하여 클라이언트의 요청을 처리할 적합한 서비스로 라우팅 합니다.

- Circuit Breaker
  
  : 특정 서비스에서의 장애가 다른 서비스로 전파되지 않도록 합니다.

- Message Queue

  : 서비스들 간의 통신은 비동기로 구현하여 서비스들 간의 통신으로 인한 의존성이 발생하지 않도록 합니다.

**마무리**

앞으로의 연재는 이 구성들을 주제로 다루게 될 텐데, 필요에 따라서는 더 추가 되거나 하나의 주제가 여러 포스트를 통해 다뤄질 수 있습니다. 기술 스택은 Netflix OSS(Netflix Open Source Software)를 제공하는 Spring Cloud Netflix를 이용하도록 하겠습니다.

다음 포스트부터는 Service Discovery 패턴 구현을 시작으로, 본격적으로 MSA 기반의 시스템을 개발하는 내용을 다루도록 하겠습니다.

References
